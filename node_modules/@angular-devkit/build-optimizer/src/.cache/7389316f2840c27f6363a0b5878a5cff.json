{"remainingRequest":"D:\\AHLinesUI\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js??ref--3-1!D:\\AHLinesUI\\node_modules\\rxjs\\_esm5\\internal\\operators\\bufferTime.js","dependencies":[{"path":"D:\\AHLinesUI\\node_modules\\rxjs\\_esm5\\internal\\operators\\bufferTime.js","mtime":499162500000},{"path":"D:\\AHLinesUI\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1522837491125},{"path":"D:\\AHLinesUI\\node_modules\\@angular-devkit\\build-optimizer\\src\\build-optimizer\\webpack-loader.js","mtime":1519266497000}],"contextDependencies":[],"result":["/** PURE_IMPORTS_START tslib,_scheduler_async,_Subscriber,_util_isScheduler PURE_IMPORTS_END */\r\nimport * as tslib_1 from \"tslib\";\r\nimport { async } from '../scheduler/async';\r\nimport { Subscriber } from '../Subscriber';\r\nimport { isScheduler } from '../util/isScheduler';\r\nexport function bufferTime(bufferTimeSpan) {\r\n    var length = arguments.length;\r\n    var scheduler = async;\r\n    if (isScheduler(arguments[arguments.length - 1])) {\r\n        scheduler = arguments[arguments.length - 1];\r\n        length--;\r\n    }\r\n    var bufferCreationInterval = null;\r\n    if (length >= 2) {\r\n        bufferCreationInterval = arguments[1];\r\n    }\r\n    var maxBufferSize = Number.POSITIVE_INFINITY;\r\n    if (length >= 3) {\r\n        maxBufferSize = arguments[2];\r\n    }\r\n    return function bufferTimeOperatorFunction(source) {\r\n        return source.lift(new BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler));\r\n    };\r\n}\r\nvar BufferTimeOperator = /*@__PURE__*/ (function () {\r\n    function BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {\r\n        this.bufferTimeSpan = bufferTimeSpan;\r\n        this.bufferCreationInterval = bufferCreationInterval;\r\n        this.maxBufferSize = maxBufferSize;\r\n        this.scheduler = scheduler;\r\n    }\r\n    BufferTimeOperator.prototype.call = function (subscriber, source) {\r\n        return source.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));\r\n    };\r\n    return BufferTimeOperator;\r\n}());\r\nvar Context = /*@__PURE__*/ (function () {\r\n    function Context() {\r\n        this.buffer = [];\r\n    }\r\n    return Context;\r\n}());\r\nvar BufferTimeSubscriber = (function (_super) {\r\n    tslib_1.__extends(BufferTimeSubscriber, _super);\r\n    function BufferTimeSubscriber(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {\r\n        var _this = _super.call(this, destination) || this;\r\n        _this.bufferTimeSpan = bufferTimeSpan;\r\n        _this.bufferCreationInterval = bufferCreationInterval;\r\n        _this.maxBufferSize = maxBufferSize;\r\n        _this.scheduler = scheduler;\r\n        _this.contexts = [];\r\n        var context = _this.openContext();\r\n        _this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;\r\n        if (_this.timespanOnly) {\r\n            var timeSpanOnlyState = { subscriber: _this, context: context, bufferTimeSpan: bufferTimeSpan };\r\n            _this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\r\n        }\r\n        else {\r\n            var closeState = { subscriber: _this, context: context };\r\n            var creationState = { bufferTimeSpan: bufferTimeSpan, bufferCreationInterval: bufferCreationInterval, subscriber: _this, scheduler: scheduler };\r\n            _this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));\r\n            _this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));\r\n        }\r\n        return _this;\r\n    }\r\n    BufferTimeSubscriber.prototype._next = function (value) {\r\n        var contexts = this.contexts;\r\n        var len = contexts.length;\r\n        var filledBufferContext;\r\n        for (var i = 0; i < len; i++) {\r\n            var context_1 = contexts[i];\r\n            var buffer = context_1.buffer;\r\n            buffer.push(value);\r\n            if (buffer.length == this.maxBufferSize) {\r\n                filledBufferContext = context_1;\r\n            }\r\n        }\r\n        if (filledBufferContext) {\r\n            this.onBufferFull(filledBufferContext);\r\n        }\r\n    };\r\n    BufferTimeSubscriber.prototype._error = function (err) {\r\n        this.contexts.length = 0;\r\n        _super.prototype._error.call(this, err);\r\n    };\r\n    BufferTimeSubscriber.prototype._complete = function () {\r\n        var _a = this, contexts = _a.contexts, destination = _a.destination;\r\n        while (contexts.length > 0) {\r\n            var context_2 = contexts.shift();\r\n            destination.next(context_2.buffer);\r\n        }\r\n        _super.prototype._complete.call(this);\r\n    };\r\n    BufferTimeSubscriber.prototype._unsubscribe = function () {\r\n        this.contexts = null;\r\n    };\r\n    BufferTimeSubscriber.prototype.onBufferFull = function (context) {\r\n        this.closeContext(context);\r\n        var closeAction = context.closeAction;\r\n        closeAction.unsubscribe();\r\n        this.remove(closeAction);\r\n        if (!this.closed && this.timespanOnly) {\r\n            context = this.openContext();\r\n            var bufferTimeSpan = this.bufferTimeSpan;\r\n            var timeSpanOnlyState = { subscriber: this, context: context, bufferTimeSpan: bufferTimeSpan };\r\n            this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));\r\n        }\r\n    };\r\n    BufferTimeSubscriber.prototype.openContext = function () {\r\n        var context = new Context();\r\n        this.contexts.push(context);\r\n        return context;\r\n    };\r\n    BufferTimeSubscriber.prototype.closeContext = function (context) {\r\n        this.destination.next(context.buffer);\r\n        var contexts = this.contexts;\r\n        var spliceIndex = contexts ? contexts.indexOf(context) : -1;\r\n        if (spliceIndex >= 0) {\r\n            contexts.splice(contexts.indexOf(context), 1);\r\n        }\r\n    };\r\n    return BufferTimeSubscriber;\r\n}(Subscriber));\r\nfunction dispatchBufferTimeSpanOnly(state) {\r\n    var subscriber = state.subscriber;\r\n    var prevContext = state.context;\r\n    if (prevContext) {\r\n        subscriber.closeContext(prevContext);\r\n    }\r\n    if (!subscriber.closed) {\r\n        state.context = subscriber.openContext();\r\n        state.context.closeAction = this.schedule(state, state.bufferTimeSpan);\r\n    }\r\n}\r\nfunction dispatchBufferCreation(state) {\r\n    var bufferCreationInterval = state.bufferCreationInterval, bufferTimeSpan = state.bufferTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler;\r\n    var context = subscriber.openContext();\r\n    var action = this;\r\n    if (!subscriber.closed) {\r\n        subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, { subscriber: subscriber, context: context }));\r\n        action.schedule(state, bufferCreationInterval);\r\n    }\r\n}\r\nfunction dispatchBufferClose(arg) {\r\n    var subscriber = arg.subscriber, context = arg.context;\r\n    subscriber.closeContext(context);\r\n}\r\n//# sourceMappingURL=bufferTime.js.map\r\n",null]}